name: TASK006 - Admin upload to Storage via server API + Tabs/Scroll in products modal

on:
  workflow_dispatch:

permissions:
  contents: write

jobs:
  task006:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Ensure deps + add README env notes
        shell: bash
        run: |
          node - <<'NODE'
          const fs = require('fs')
          const pkg = JSON.parse(fs.readFileSync('package.json','utf8'))

          pkg.devDependencies = pkg.devDependencies || {}
          if (!pkg.devDependencies['firebase-admin']) pkg.devDependencies['firebase-admin'] = '^12.5.0'

          fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\n')
          NODE

          cat >> README.md <<'EOF'

          ---

          ## TASK006: Upload images to Firebase Storage from Admin (server API)

          Адмін входить фіксованим логіном/паролем (без Firebase Auth), тому завантаження у Storage робимо через серверний API
          з `firebase-admin`.

          ### ENV змінні (для локального запуску і Vercel)
          1) Bucket:
          - `FIREBASE_STORAGE_BUCKET` = `your-project-id.appspot.com`

          2) Service account:
          **Варіант A (рекомендовано):**
          - `FIREBASE_ADMIN_CREDENTIALS_JSON` = *вміст serviceAccountKey.json як один JSON-рядок*

          **Варіант B (локально):**
          - `GOOGLE_APPLICATION_CREDENTIALS` = шлях до serviceAccountKey.json

          > На Vercel зручніше використовувати варіант A (JSON в env).
          EOF

      - name: Add server utils firebase-admin
        shell: bash
        run: |
          mkdir -p server/utils
          cat > server/utils/firebaseAdmin.ts <<'EOF'
          import admin from 'firebase-admin'
          import fs from 'node:fs'

          let _app: admin.app.App | null = null

          function readServiceAccountFromEnv() {
            const json = process.env.FIREBASE_ADMIN_CREDENTIALS_JSON
            if (json && json.trim().startsWith('{')) {
              return JSON.parse(json)
            }

            const path = process.env.GOOGLE_APPLICATION_CREDENTIALS
            if (path && fs.existsSync(path)) {
              return JSON.parse(fs.readFileSync(path, 'utf8'))
            }

            return null
          }

          export function getAdminApp() {
            if (_app) return _app

            const serviceAccount = readServiceAccountFromEnv()
            if (!serviceAccount) {
              throw new Error(
                'Missing Firebase Admin credentials. Set FIREBASE_ADMIN_CREDENTIALS_JSON (recommended) or GOOGLE_APPLICATION_CREDENTIALS.'
              )
            }

            const storageBucket = process.env.FIREBASE_STORAGE_BUCKET
            if (!storageBucket) {
              throw new Error('Missing FIREBASE_STORAGE_BUCKET (e.g. your-project-id.appspot.com)')
            }

            _app = admin.initializeApp({
              credential: admin.credential.cert(serviceAccount as any),
              storageBucket
            })

            return _app
          }
          EOF

      - name: Add server API upload endpoint
        shell: bash
        run: |
          mkdir -p server/api/admin
          cat > server/api/admin/upload.post.ts <<'EOF'
          import { defineEventHandler, readMultipartFormData, getCookie, createError } from 'h3'
          import crypto from 'node:crypto'
          import { getAdminApp } from '~/server/utils/firebaseAdmin'
          import admin from 'firebase-admin'

          function isAdminFromCookie(event: any): boolean {
            const raw = getCookie(event, 'fixed_session')
            if (!raw) return false

            // Nuxt useCookie(object) stores JSON in cookie. On server it's a string.
            try {
              const parsed = JSON.parse(raw)
              return parsed?.kind === 'admin'
            } catch {
              // sometimes cookie may be double-encoded
              try {
                const parsed = JSON.parse(decodeURIComponent(raw))
                return parsed?.kind === 'admin'
              } catch {
                return false
              }
            }
          }

          export default defineEventHandler(async (event) => {
            if (!isAdminFromCookie(event)) {
              throw createError({ statusCode: 401, statusMessage: 'Unauthorized' })
            }

            const form = await readMultipartFormData(event)
            if (!form) throw createError({ statusCode: 400, statusMessage: 'No form data' })

            const file = form.find((p) => p.name === 'file')
            if (!file || !('data' in file) || !file.data) {
              throw createError({ statusCode: 400, statusMessage: 'Missing file' })
            }

            const original = String((file as any).filename || 'image')
            const ext = (original.includes('.') ? original.split('.').pop() : 'jpg')?.toLowerCase() || 'jpg'
            const safeExt = ['jpg','said','jpeg','png','webp'].includes(ext) ? ext : 'jpg'

            const productId = String((form.find(p => p.name === 'productId') as any)?.data?.toString?.() || '').trim()
            const baseName = productId ? `products/${productId}` : `products/${Date.now()}_${crypto.randomBytes(3).toString('hex')}`
            const filePath = `${baseName}.${safeExt}`

            // init admin
            getAdminApp()
            const bucket = admin.storage().bucket()

            // token for Firebase download URL
            const token = crypto.randomUUID()

            const contentType =
              safeExt === 'png' ? 'image/png'
              : safeExt === 'webp' ? 'image/webp'
              : 'image/jpeg'

            const f = bucket.file(filePath)
            await f.save(file.data, {
              resumable: false,
              metadata: {
                contentType,
                metadata: {
                  firebaseStorageDownloadTokens: token
                }
              }
            })

            const bucketName = bucket.name
            const downloadURL =
              `https://firebasestorage.googleapis.com/v0/b/${bucketName}/o/${encodeURIComponent(filePath)}?alt=media&token=${token}`

            return {
              ok: true,
              filePath,
              downloadURL
            }
          })
          EOF

      - name: Overwrite pages/admin/products.vue (tabs + scroll + upload)
        shell: bash
        run: |
          mkdir -p pages/admin
          cat > pages/admin/products.vue <<'EOF'
          <template>
            <div class="grid gap-6">
              <div class="rounded-2xl border bg-white p-5 shadow-sm">
                <h1 class="text-xl font-bold">Адмін • Товари</h1>
                <p class="mt-1 text-sm text-gray-600">
                  Стартові зображення: <span class="font-semibold">/public/images/</span> (поле <code>imagePath</code>).
                  Якщо адмін завантажує файл — він піде в <span class="font-semibold">Storage</span>, а у товарі запишеться <code>imageUrl</code>.
                </p>

                <div class="mt-4">
                  <UiButton variant="primary" @click="openCreate">Додати товар</UiButton>
                </div>
              </div>

              <div class="rounded-2xl border bg-white p-5 shadow-sm">
                <div v-if="loading" class="text-sm text-gray-600">Завантаження...</div>

                <div v-else class="grid gap-3">
                  <div
                    v-for="p in products"
                    :key="p.id"
                    class="flex flex-wrap items-center justify-between gap-3 rounded-xl border p-3"
                  >
                    <div class="min-w-[280px]">
                      <div class="text-sm font-semibold">{{ p.name }}</div>
                      <div class="text-xs text-gray-500">{{ p.parentCategory }} / {{ p.childCategory }}</div>
                      <div class="text-xs text-gray-500">{{ formatPrice(p.price) }} • {{ p.unit }}</div>
                    </div>

                    <div class="flex gap-2">
                      <UiButton @click="openEdit(p)">Редагувати</UiButton>
                      <UiButton variant="danger" @click="onDelete(p.id)">Видалити</UiButton>
                    </div>
                  </div>

                  <div v-if="products.length === 0" class="text-sm text-gray-600">
                    Товарів поки немає.
                  </div>
                </div>
              </div>

              <!-- MODAL -->
              <div v-if="showForm" class="fixed inset-0 z-50 bg-black/40 p-3 md:p-6">
                <div class="mx-auto flex h-[92vh] w-full max-w-6xl flex-col overflow-hidden rounded-2xl bg-white shadow-xl">
                  <!-- Header -->
                  <div class="flex items-center justify-between gap-3 border-b px-5 py-4">
                    <div class="min-w-0">
                      <h2 class="truncate text-lg font-semibold">
                        {{ formMode === 'create' ? 'Додати товар' : 'Редагувати товар' }}
                      </h2>
                      <div class="mt-0.5 text-xs text-gray-500">
                        Вкладки зручніші за скрол всієї сторінки. Скрол є тільки всередині модалки.
                      </div>
                    </div>

                    <button class="rounded-xl border px-3 py-1 text-sm hover:bg-gray-50" @click="closeForm">✕</button>
                  </div>

                  <!-- Tabs -->
                  <div class="flex gap-2 border-b px-5 py-3">
                    <button
                      class="rounded-xl px-3 py-2 text-sm"
                      :class="tab==='main' ? 'bg-gray-900 text-white' : 'border hover:bg-gray-50'"
                      @click="tab='main'"
                      type="button"
                    >
                      Основне
                    </button>
                    <button
                      class="rounded-xl px-3 py-2 text-sm"
                      :class="tab==='desc' ? 'bg-gray-900 text-white' : 'border hover:bg-gray-50'"
                      @click="tab='desc'"
                      type="button"
                    >
                      Опис
                    </button>
                  </div>

                  <!-- Body (scroll area) -->
                  <form class="flex-1 overflow-y-auto px-5 py-4" @submit.prevent="save">
                    <!-- MAIN TAB -->
                    <div v-show="tab==='main'" class="grid gap-4">
                      <div class="grid gap-3 md:grid-cols-2">
                        <label class="grid gap-1">
                          <span class="text-sm text-gray-700">Назва</span>
                          <input v-model.trim="form.name" required class="rounded-xl border px-3 py-2" />
                        </label>

                        <label class="grid gap-1">
                          <span class="text-sm text-gray-700">Одиниці (unit)</span>
                          <input v-model.trim="form.unit" required class="rounded-xl border px-3 py-2" />
                        </label>

                        <label class="grid gap-1">
                          <span class="text-sm text-gray-700">Категорія (1 рівень)</span>
                          <select v-model="form.parentCategory" required class="rounded-xl border px-3 py-2" @change="onParentChanged">
                            <option value="" disabled>— Оберіть —</option>
                            <option v-for="p in parents" :key="p" :value="p">{{ p }}</option>
                          </select>
                        </label>

                        <label class="grid gap-1">
                          <span class="text-sm text-gray-700">Підкатегорія (2 рівень)</span>
                          <select v-model="form.childCategory" required class="rounded-xl border px-3 py-2" :disabled="!form.parentCategory">
                            <option value="" disabled>— Оберіть —</option>
                            <option v-for="c in children" :key="c" :value="c">{{ c }}</option>
                          </select>
                        </label>

                        <label class="grid gap-1">
                          <span class="text-sm text-gray-700">Виробник (manufacturer)</span>
                          <input v-model.trim="form.manufacturer" required class="rounded-xl border px-3 py-2" />
                        </label>

                        <label class="grid gap-1">
                          <span class="text-sm text-gray-700">Ціна (грн)</span>
                          <input v-model.number="form.price" type="number" min="0" step="0.01" required class="rounded-xl border px-3 py-2" />
                        </label>
                      </div>

                      <div class="grid gap-3 md:grid-cols-2">
                        <div class="rounded-2xl border p-4">
                          <div class="text-sm font-semibold">Зображення</div>

                          <div class="mt-3 grid gap-2">
                            <div class="text-xs text-gray-500">Поточне (Storage або local)</div>
                            <div class="aspect-square overflow-hidden rounded-xl bg-gray-100">
                              <img v-if="previewSrc" :src="previewSrc" class="h-full w-full object-cover" alt="" />
                            </div>

                            <div class="grid gap-1">
                              <span class="text-sm text-gray-700">Стартове локальне imagePath</span>
                              <input v-model.trim="form.imagePath" placeholder="images/002.webp" class="rounded-xl border px-3 py-2" />
                              <span class="text-xs text-gray-500">
                                Це для стартової колекції (в <code>/public/images</code>).
                              </span>
                            </div>

                            <div class="grid gap-1">
                              <span class="text-sm text-gray-700">Storage imageUrl (заповнюється після upload)</span>
                              <input v-model.trim="form.imageUrl" placeholder="https://firebasestorage.googleapis.com/..." class="rounded-xl border px-3 py-2" />
                            </div>

                            <div class="grid gap-2 pt-2">
                              <span class="text-sm text-gray-700">Завантажити нове зображення в Storage</span>
                              <input type="file" accept="image/*" class="block w-full text-sm" @change="onFileChange" />
                              <div class="text-xs text-gray-500">
                                Після вибору файлу він завантажиться в Storage при натисканні <b>Зберегти</b>.
                              </div>
                            </div>
                          </div>
                        </div>

                        <div class="rounded-2xl border p-4">
                          <div class="text-sm font-semibold">Підказка</div>
                          <div class="mt-2 text-sm text-gray-700 leading-6">
                            Якщо завантажуєш файл — ми записуємо <code>imageUrl</code>.
                            <br />
                            Якщо файл не завантажуєш — картинка береться з <code>imagePath</code> (локально).
                          </div>
                        </div>
                      </div>
                    </div>

                    <!-- DESC TAB -->
                    <div v-show="tab==='desc'" class="grid gap-3 md:grid-cols-2">
                      <Field label="Склад" v-model="form.description.composition" />
                      <Field label="Лікарська форма" v-model="form.description.dosageForm" />
                      <Field label="Фармакотерапевтична група" v-model="form.description.pharmacotherapeuticGroup" />
                      <Field label="Фармакологічні властивості" v-model="form.description.pharmacologicalProperties" />
                      <Field label="Показання" v-model="form.description.indications" />
                      <Field label="Протипоказання" v-model="form.description.contraindications" />
                      <Field label="Спосіб застосування та дози" v-model="form.description.dosageAndAdministration" />
                      <Field label="Термін придатності" v-model="form.description.shelfLife" />
                      <Field label="Умови зберігання" v-model="form.description.storageConditions" />
                      <Field label="Упаковка" v-model="form.description.packaging" />
                      <Field label="Виробник" v-model="form.description.manufacturerInfo" class="md:col-span-2" />
                    </div>

                    <AlertBox :text="msg" :kind="msgKind" />
                  </form>

                  <!-- Footer -->
                  <div class="flex justify-end gap-2 border-t px-5 py-4">
                    <UiButton @click="closeForm">Скасувати</UiButton>
                    <UiButton type="button" variant="primary" :disabled="saving" @click="save">
                      {{ saving ? 'Збереження...' : 'Зберегти' }}
                    </UiButton>
                  </div>
                </div>
              </div>
            </div>
          </template>

          <script setup lang="ts">
          import { CATEGORIES } from '~/data/categories'

          onMounted(async () => {
            await requireRole('admin')
          })

          const { products, loading, fetchAll, create, update, remove } = useProducts() as any

          const showForm = ref(false)
          const formMode = ref<'create' | 'edit'>('create')
          const editingId = ref<string | null>(null)

          const parents = computed(() => Object.keys(CATEGORIES))
          const children = computed(() => {
            const p = form.parentCategory
            if (!p) return []
            return (CATEGORIES as any)[p] as string[]
          })

          const tab = ref<'main'|'desc'>('main')

          const fileToUpload = ref<File | null>(null)

          const form = reactive<any>({
            name: '',
            unit: '',
            imagePath: '',
            imageUrl: '',
            parentCategory: '',
            childCategory: '',
            manufacturer: '',
            price: 0,
            description: {
              composition: '',
              dosageForm: '',
              pharmacotherapeuticGroup: '',
              pharmacologicalProperties: '',
              indications: '',
              contraindications: '',
              dosageAndAdministration: '',
              shelfLife: '',
              storageConditions: '',
              packaging: '',
              manufacturerInfo: ''
            }
          })

          const saving = ref(false)
          const msg = ref('')
          const msgKind = ref<'info'|'error'|'success'>('info')

          onMounted(async () => {
            await fetchAll()
          })

          function formatPrice(v: any) {
            const n = Number(v || 0)
            return `${n.toFixed(2)} грн`
          }

          function normalizeLocalImagePath(imagePath: string) {
            const raw = String(imagePath || '').trim().replace(/\\/g, '/')
            if (!raw) return ''
            const rel = raw.includes('/') ? raw.replace(/^\/+/, '') : `images/${raw}`
            return '/' + rel
          }

          const previewSrc = computed(() => {
            if (form.imageUrl) return form.imageUrl
            if (form.imagePath) return normalizeLocalImagePath(form.imagePath)
            return ''
          })

          function openCreate () {
            formMode.value = 'create'
            editingId.value = null
            tab.value = 'main'
            fileToUpload.value = null

            form.name = ''
            form.unit = ''
            form.imagePath = ''
            form.imageUrl = ''
            form.parentCategory = parents.value[0] || ''
            form.childCategory = ''
            form.manufacturer = ''
            form.price = 0
            Object.assign(form.description, {
              composition: '',
              dosageForm: '',
              pharmacotherapeuticGroup: '',
              pharmacologicalProperties: '',
              indications: '',
              contraindications: '',
              dosageAndAdministration: '',
              shelfLife: '',
              storageConditions: '',
              packaging: '',
              manufacturerInfo: ''
            })

            showForm.value = true
            msg.value = ''
          }

          function openEdit (p: any) {
            formMode.value = 'edit'
            editingId.value = p.id || null
            tab.value = 'main'
            fileToUpload.value = null

            form.name = p.name || ''
            form.unit = p.unit || ''
            form.imagePath = p.imagePath || ''
            form.imageUrl = p.imageUrl || ''
            form.parentCategory = p.parentCategory || parents.value[0] || ''
            form.childCategory = p.childCategory || ''
            form.manufacturer = p.manufacturer || ''
            form.price = Number(p.price || 0)

            Object.assign(form.description, {
              composition: p.description?.composition || '',
              dosageForm: p.description?.dosageForm || '',
              pharmacotherapeuticGroup: p.description?.pharmacotherapeuticGroup || '',
              pharmacologicalProperties: p.description?.pharmacologicalProperties || '',
              indications: p.description?.indications || '',
              contraindications: p.description?.contraindications || '',
              dosageAndAdministration: p.description?.dosageAndAdministration || '',
              shelfLife: p.description?.shelfLife || '',
              storageConditions: p.description?.storageConditions || '',
              packaging: p.description?.packaging || '',
              manufacturerInfo: p.description?.manufacturerInfo || ''
            })

            showForm.value = true
            msg.value = ''
          }

          function closeForm () {
            showForm.value = false
            fileToUpload.value = null
          }

          function onParentChanged () {
            form.childCategory = ''
          }

          function onFileChange (e: Event) {
            const input = e.target as HTMLInputElement
            const f = input.files?.[0] || null
            fileToUpload.value = f
          }

          async function uploadImageIfNeeded(productId: string | null) {
            if (!fileToUpload.value) return null

            const fd = new FormData()
            fd.append('file', fileToUpload.value)
            if (productId) fd.append('productId', productId)

            const res = await $fetch<any>('/api/admin/upload', {
              method: 'POST',
              body: fd
            })

            if (!res?.ok) throw new Error('Upload failed')
            return { downloadURL: res.downloadURL as string, filePath: res.filePath as string }
          }

          async function save () {
            msg.value = ''
            if (!form.childCategory) {
              msgKind.value = 'error'
              msg.value = 'Оберіть підкатегорію (2 рівень).'
              tab.value = 'main'
              return
            }

            saving.value = true
            try {
              // 1) build payload (without upload first)
              const payload: any = {
                name: form.name,
                unit: form.unit,
                imagePath: form.imagePath,
                imageUrl: form.imageUrl,
                parentCategory: form.parentCategory,
                childCategory: form.childCategory,
                manufacturer: form.manufacturer,
                price: Number(form.price || 0),
                description: { ...form.description }
              }

              // 2) If create: create first to get id, then upload and update imageUrl
              if (formMode.value === 'create') {
                const created = await create(payload) // expect it may return id; if not, we fallback by refetch
                const newId = typeof created === 'string' ? created : (created?.id || null)

                const up = await uploadImageIfNeeded(newId)
                if (up?.downloadURL) {
                  payload.imageUrl = up.downloadURL
                  // after upload, imageUrl wins. imagePath can stay as is (starter) or be cleared; we keep it.
                  if (newId) await update(newId, payload)
                }
              } else if (editingId.value) {
                // edit: upload first (so we store imageUrl) then update
                const up = await uploadImageIfNeeded(editingId.value)
                if (up?.downloadURL) payload.imageUrl = up.downloadURL
                await update(editingId.value, payload)
              }

              msgKind.value = 'success'
              msg.value = 'Збережено.'
              await fetchAll()
              showForm.value = false
              fileToUpload.value = null
            } catch (e: any) {
              msgKind.value = 'error'
              msg.value = e?.data?.message || e?.message || 'Помилка збереження.'
            } finally {
              saving.value = false
            }
          }

          async function onDelete (id: string) {
            const ok = confirm('Видалити товар?')
            if (!ok) return
            try {
              await remove(id)
              await fetchAll()
            } catch (e: any) {
              alert(e?.message || 'Помилка видалення.')
            }
          }

          const Field = defineComponent({
            props: {
              label: { type: String, required: true },
              modelValue: { type: String, default: '' }
            },
            emits: ['update:modelValue'],
            setup(props, { emit, attrs }) {
              return () => h('label', { class: ['grid gap-1', (attrs as any).class || ''] }, [
                h('span', { class: 'text-sm text-gray-700' }, props.label),
                h('textarea', {
                  class: 'rounded-xl border px-3 py-2',
                  rows: 3,
                  value: props.modelValue,
                  onInput: (e: any) => emit('update:modelValue', e.target.value)
                })
              ])
            }
          })
          </script>
          EOF

      - name: Commit & push
        shell: bash
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add package.json server/utils/firebaseAdmin.ts server/api/admin/upload.post.ts pages/admin/products.vue README.md
          git commit -m "TASK006: admin image upload to Storage via server API + tabs/scroll in modal" || echo "No changes to commit"
          git push
